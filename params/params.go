package params

import (
    "flag"
    "fmt"
    "strings"
    "os"
    "path/filepath"
    "io/ioutil"
    "encoding/xml"
    "strconv"
    "regexp"
)

type PluginXML struct {
    Key string `xml:"key"`
    Version string `xml:"version"`
}

type PluginMeta struct {
    Name         string
    Version      string
    Directory    string
    Folders    []string
}


type CommandLineArguments struct {
    Version string
    Name string
    BuildNumber string
    Directory string
    Folders []string
    IncrementBuildNumber bool
    AddDeveloperSuffix bool
    PreserveBuild bool
    IsJar bool
    DependencyChunkSize int
}

type strslice []string

func(s *strslice) String() string {
    return fmt.Sprintf("%s", *s)
}

func(s *strslice) Set(value string) (err error) {
    re, _ := regexp.Compile(",\\s*")

    if re.MatchString(value) {
        values := re.Split(value, -1)
        *s = append(*s, values...)
    } else {
        *s = append(*s, value)
    }
    return nil
}

func GetCommandLineArguments() (args CommandLineArguments) {
    versionPtr := flag.String("plugin-version", "", "Plugin Version")
    namePtr := flag.String("plugin-name", "", "Plugin name")
    pluginDirPtr := flag.String("plugin-dir", "", "Plugin directory")
    preserveBuildPtr := flag.Bool("preserve-build", true, "If set to false, an existing build directory will not be cleaned up")
    isJarPtr := flag.Bool("pack-jar", false, "If set to true, the .jar will be built instead of .zip")
    depChunkSizePtr := flag.Int("dependency-chunk-size", 10 * 1024 * 1024, "Dependencies chuunk size (default it 10 MB)")

    var folders strslice
    flag.Var(&folders, "folder", "List of folders to pack")
    incrementBuildNumberPtr := flag.Bool("increment-build-number", false, "If provided, new build number will be generated by incrementing current build number")
    flag.Parse()

    args.Version = *versionPtr
    args.Name = *namePtr
    args.Directory = *pluginDirPtr
    args.IncrementBuildNumber = *incrementBuildNumberPtr
    args.Folders = folders
    args.PreserveBuild = *preserveBuildPtr
    args.IsJar = *isJarPtr
    args.DependencyChunkSize = *depChunkSizePtr

    return
}



func AugmentPluginVersion(currentVersion, buildNumber string) (string, error) {
    if buildNumber == "" {
        return currentVersion, nil
    }
    parts := strings.Split(currentVersion, ".")
    if len(parts) == 3 {
        parts = append(parts, buildNumber)
    } else if len(parts) == 4 {
        parts[3] = buildNumber
    } else {
        err := fmt.Errorf("Cannot recognize version format %s", currentVersion)
        return currentVersion, err
    }
    newVersion := strings.Join(parts, ".")
    return newVersion, nil
}

func getBuildNumberFromVersion(version string) string {
    parts := strings.Split(version, ".")
    if len(parts) == 4 {
        return parts[3]
    } else {
        return ""
    }
}

func GetPluginDirectory(args CommandLineArguments) (string, error) {
    if args.Directory != "" {
        return args.Directory, nil
    }
    cwd, err := os.Getwd()
    // TODO maybe we need gitroot here
    return cwd, err
}

func GetPluginVersion(args CommandLineArguments, pluginXML PluginXML) (buildNumber string, err error) {
    if args.BuildNumber != "" {
        buildNumber = args.BuildNumber
    } else if os.Getenv("BUILD_NUMBER") != "" {
        buildNumber = os.Getenv("BUILD_NUMBER")
    }

    var pluginVersion string
    if args.Version != "" {
        pluginVersion = args.Version
    } else {
        pluginVersion = pluginXML.Version
    }

    if pluginVersion == "" {
        return "", fmt.Errorf("Cannot determine plugin version")
    }

    if buildNumber == "" {
        buildNumber = getBuildNumberFromVersion(pluginVersion)
    }

    if args.IncrementBuildNumber {
        var numericBuild int
        if buildNumber == "" {
            numericBuild = 0
        } else {
            numericBuild, err = strconv.Atoi(buildNumber)
            if err != nil {
                return pluginVersion, err
            }
        }
        numericBuild += 1
        buildNumber = strconv.Itoa(numericBuild)
    }

    pluginVersion, err = AugmentPluginVersion(pluginVersion, buildNumber)
    return pluginVersion, err
}

func GetPluginName(args CommandLineArguments, pluginXml PluginXML) (string, error) {
    if args.Name != "" {
        return args.Name, nil
    }
    if pluginXml.Key != "" {
        return pluginXml.Key, nil
    }
    return "", fmt.Errorf("Cannot determine plugin name")
}

func ReadPluginXML(pluginDirectory string) (p PluginXML, err error) {
    pluginXmlPath := filepath.Join(pluginDirectory, "META-INF", "plugin.xml")
    xmlFile, err := os.Open(pluginXmlPath)
    if err != nil {
        return
    }
    defer xmlFile.Close()

    b, err := ioutil.ReadAll(xmlFile)
    if err != nil {
        return
    }
    xml.Unmarshal(b, &p)
    return
}

func GetFoldersToPack(args CommandLineArguments) (folders []string, err error) {
    if args.Folders != nil {
        folders = args.Folders
        return
    }

    pluginDirectory, err := GetPluginDirectory(args)
    if err != nil {
        return
    }
    files, err := ioutil.ReadDir(pluginDirectory)
    if err != nil {
        return
    }
    for _, f := range files {
        if f.IsDir() && !strings.HasPrefix(f.Name(), ".") && f.Name() != "build" && f.Name() != "lib" {
            folders = append(folders, f.Name())
        }
    }
    return
}

